/*
 * generated by Xtext 2.36.0
 */
package wodel.dsls.serializer;

import com.google.inject.Inject;
import java.util.Set;
import mutatorenvironment.AttributeCopy;
import mutatorenvironment.AttributeEvaluation;
import mutatorenvironment.AttributeOperation;
import mutatorenvironment.AttributeReverse;
import mutatorenvironment.AttributeScalar;
import mutatorenvironment.AttributeSwap;
import mutatorenvironment.AttributeUnset;
import mutatorenvironment.BinaryOperator;
import mutatorenvironment.Block;
import mutatorenvironment.CatEndStringType;
import mutatorenvironment.CatStartStringType;
import mutatorenvironment.CloneObjectMutator;
import mutatorenvironment.CompleteTypeSelection;
import mutatorenvironment.CompositeMutator;
import mutatorenvironment.Constraint;
import mutatorenvironment.CreateObjectMutator;
import mutatorenvironment.CreateReferenceMutator;
import mutatorenvironment.Expression;
import mutatorenvironment.Library;
import mutatorenvironment.ListStringType;
import mutatorenvironment.ListType;
import mutatorenvironment.Load;
import mutatorenvironment.LowerStringType;
import mutatorenvironment.MaxValueType;
import mutatorenvironment.MinValueType;
import mutatorenvironment.ModifyInformationMutator;
import mutatorenvironment.ModifySourceReferenceMutator;
import mutatorenvironment.ModifyTargetReferenceMutator;
import mutatorenvironment.MutatorEnvironment;
import mutatorenvironment.MutatorenvironmentPackage;
import mutatorenvironment.ObjectAttributeType;
import mutatorenvironment.OtherTypeSelection;
import mutatorenvironment.Program;
import mutatorenvironment.RandomBooleanType;
import mutatorenvironment.RandomDoubleNumberType;
import mutatorenvironment.RandomDoubleType;
import mutatorenvironment.RandomIntegerNumberType;
import mutatorenvironment.RandomIntegerType;
import mutatorenvironment.RandomStringNumberType;
import mutatorenvironment.RandomStringType;
import mutatorenvironment.RandomType;
import mutatorenvironment.RandomTypeSelection;
import mutatorenvironment.ReferenceAdd;
import mutatorenvironment.ReferenceAtt;
import mutatorenvironment.ReferenceEvaluation;
import mutatorenvironment.ReferenceInit;
import mutatorenvironment.ReferenceRemove;
import mutatorenvironment.ReferenceSwap;
import mutatorenvironment.RemoveCompleteReferenceMutator;
import mutatorenvironment.RemoveObjectMutator;
import mutatorenvironment.RemoveRandomReferenceMutator;
import mutatorenvironment.RemoveSpecificReferenceMutator;
import mutatorenvironment.ReplaceStringType;
import mutatorenvironment.Resource;
import mutatorenvironment.RetypeObjectMutator;
import mutatorenvironment.SelectObjectMutator;
import mutatorenvironment.SelectSampleMutator;
import mutatorenvironment.Source;
import mutatorenvironment.SpecificBooleanType;
import mutatorenvironment.SpecificClosureSelection;
import mutatorenvironment.SpecificDoubleType;
import mutatorenvironment.SpecificIntegerType;
import mutatorenvironment.SpecificObjectSelection;
import mutatorenvironment.SpecificStringType;
import mutatorenvironment.TypedSelection;
import mutatorenvironment.UpperStringType;
import mutatorenvironment.miniOCL.AccVarCS;
import mutatorenvironment.miniOCL.BooleanExpCS;
import mutatorenvironment.miniOCL.CallExpCS;
import mutatorenvironment.miniOCL.CollectExpCS;
import mutatorenvironment.miniOCL.ExistsExpCS;
import mutatorenvironment.miniOCL.ForAllExpCS;
import mutatorenvironment.miniOCL.IntLiteralExpCS;
import mutatorenvironment.miniOCL.InvariantCS;
import mutatorenvironment.miniOCL.IterateExpCS;
import mutatorenvironment.miniOCL.IteratorVarCS;
import mutatorenvironment.miniOCL.LogicExpCS;
import mutatorenvironment.miniOCL.MiniOCLPackage;
import mutatorenvironment.miniOCL.NameExpCS;
import mutatorenvironment.miniOCL.NavigationNameExpCS;
import mutatorenvironment.miniOCL.NavigationPathElementCS;
import mutatorenvironment.miniOCL.NavigationPathNameCS;
import mutatorenvironment.miniOCL.NavigationPathVariableCS;
import mutatorenvironment.miniOCL.PathElementCS;
import mutatorenvironment.miniOCL.PathNameCS;
import mutatorenvironment.miniOCL.PathVariableCS;
import mutatorenvironment.miniOCL.RoundedBracketClauseCS;
import mutatorenvironment.miniOCL.StringLiteralExpCS;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import wodel.dsls.services.WodelGrammarAccess;

@SuppressWarnings("all")
public class WodelSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private WodelGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MiniOCLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MiniOCLPackage.ACC_VAR_CS:
				sequence_AccVarCS(context, (AccVarCS) semanticObject); 
				return; 
			case MiniOCLPackage.BOOLEAN_EXP_CS:
				sequence_BooleanLiteralExpCS(context, (BooleanExpCS) semanticObject); 
				return; 
			case MiniOCLPackage.CALL_EXP_CS:
				sequence_CallExpCS(context, (CallExpCS) semanticObject); 
				return; 
			case MiniOCLPackage.COLLECT_EXP_CS:
				sequence_CollectExpCS(context, (CollectExpCS) semanticObject); 
				return; 
			case MiniOCLPackage.EXISTS_EXP_CS:
				sequence_ExistsExpCS(context, (ExistsExpCS) semanticObject); 
				return; 
			case MiniOCLPackage.FOR_ALL_EXP_CS:
				sequence_ForAllExpCS(context, (ForAllExpCS) semanticObject); 
				return; 
			case MiniOCLPackage.INT_LITERAL_EXP_CS:
				sequence_IntLiteralExpCS(context, (IntLiteralExpCS) semanticObject); 
				return; 
			case MiniOCLPackage.INVARIANT_CS:
				sequence_InvariantCS(context, (InvariantCS) semanticObject); 
				return; 
			case MiniOCLPackage.ITERATE_EXP_CS:
				sequence_IterateExpCS(context, (IterateExpCS) semanticObject); 
				return; 
			case MiniOCLPackage.ITERATOR_VAR_CS:
				sequence_IteratorVarCS(context, (IteratorVarCS) semanticObject); 
				return; 
			case MiniOCLPackage.LOGIC_EXP_CS:
				sequence_LogicExpCS(context, (LogicExpCS) semanticObject); 
				return; 
			case MiniOCLPackage.NAME_EXP_CS:
				sequence_NameExpCS(context, (NameExpCS) semanticObject); 
				return; 
			case MiniOCLPackage.NAVIGATION_NAME_EXP_CS:
				sequence_NavigationNameExpCS(context, (NavigationNameExpCS) semanticObject); 
				return; 
			case MiniOCLPackage.NAVIGATION_PATH_ELEMENT_CS:
				sequence_NavigationPathElementCS(context, (NavigationPathElementCS) semanticObject); 
				return; 
			case MiniOCLPackage.NAVIGATION_PATH_NAME_CS:
				sequence_NavigationPathNameCS(context, (NavigationPathNameCS) semanticObject); 
				return; 
			case MiniOCLPackage.NAVIGATION_PATH_VARIABLE_CS:
				sequence_NavigationPathVariableCS(context, (NavigationPathVariableCS) semanticObject); 
				return; 
			case MiniOCLPackage.PATH_ELEMENT_CS:
				sequence_PathElementCS(context, (PathElementCS) semanticObject); 
				return; 
			case MiniOCLPackage.PATH_NAME_CS:
				sequence_PathNameCS(context, (PathNameCS) semanticObject); 
				return; 
			case MiniOCLPackage.PATH_VARIABLE_CS:
				sequence_PathVariableCS(context, (PathVariableCS) semanticObject); 
				return; 
			case MiniOCLPackage.ROUNDED_BRACKET_CLAUSE_CS:
				sequence_RoundedBracketClauseCS(context, (RoundedBracketClauseCS) semanticObject); 
				return; 
			case MiniOCLPackage.STRING_LITERAL_EXP_CS:
				sequence_StringLiteralExpCS(context, (StringLiteralExpCS) semanticObject); 
				return; 
			}
		else if (epackage == MutatorenvironmentPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MutatorenvironmentPackage.ATTRIBUTE_COPY:
				sequence_AttributeCopy(context, (AttributeCopy) semanticObject); 
				return; 
			case MutatorenvironmentPackage.ATTRIBUTE_EVALUATION:
				sequence_AttributeEvaluation(context, (AttributeEvaluation) semanticObject); 
				return; 
			case MutatorenvironmentPackage.ATTRIBUTE_OPERATION:
				sequence_AttributeOperation(context, (AttributeOperation) semanticObject); 
				return; 
			case MutatorenvironmentPackage.ATTRIBUTE_REVERSE:
				sequence_AttributeReverse(context, (AttributeReverse) semanticObject); 
				return; 
			case MutatorenvironmentPackage.ATTRIBUTE_SCALAR:
				sequence_AttributeScalar(context, (AttributeScalar) semanticObject); 
				return; 
			case MutatorenvironmentPackage.ATTRIBUTE_SWAP:
				sequence_AttributeSwap(context, (AttributeSwap) semanticObject); 
				return; 
			case MutatorenvironmentPackage.ATTRIBUTE_UNSET:
				sequence_AttributeUnset(context, (AttributeUnset) semanticObject); 
				return; 
			case MutatorenvironmentPackage.BINARY_OPERATOR:
				sequence_BinaryOperator(context, (BinaryOperator) semanticObject); 
				return; 
			case MutatorenvironmentPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case MutatorenvironmentPackage.CAT_END_STRING_TYPE:
				sequence_CatEndStringType(context, (CatEndStringType) semanticObject); 
				return; 
			case MutatorenvironmentPackage.CAT_START_STRING_TYPE:
				sequence_CatStartStringType(context, (CatStartStringType) semanticObject); 
				return; 
			case MutatorenvironmentPackage.CLONE_OBJECT_MUTATOR:
				sequence_CloneObjectMutator(context, (CloneObjectMutator) semanticObject); 
				return; 
			case MutatorenvironmentPackage.COMPLETE_TYPE_SELECTION:
				sequence_CompleteTypeSelection(context, (CompleteTypeSelection) semanticObject); 
				return; 
			case MutatorenvironmentPackage.COMPOSITE_MUTATOR:
				sequence_CompositeMutator(context, (CompositeMutator) semanticObject); 
				return; 
			case MutatorenvironmentPackage.CONSTRAINT:
				sequence_Constraint(context, (Constraint) semanticObject); 
				return; 
			case MutatorenvironmentPackage.CREATE_OBJECT_MUTATOR:
				sequence_CreateObjectMutator(context, (CreateObjectMutator) semanticObject); 
				return; 
			case MutatorenvironmentPackage.CREATE_REFERENCE_MUTATOR:
				sequence_CreateReferenceMutator(context, (CreateReferenceMutator) semanticObject); 
				return; 
			case MutatorenvironmentPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case MutatorenvironmentPackage.LIBRARY:
				sequence_Library(context, (Library) semanticObject); 
				return; 
			case MutatorenvironmentPackage.LIST_STRING_TYPE:
				sequence_ListStringType(context, (ListStringType) semanticObject); 
				return; 
			case MutatorenvironmentPackage.LIST_TYPE:
				sequence_ListType(context, (ListType) semanticObject); 
				return; 
			case MutatorenvironmentPackage.LOAD:
				sequence_Load(context, (Load) semanticObject); 
				return; 
			case MutatorenvironmentPackage.LOWER_STRING_TYPE:
				sequence_LowerStringType(context, (LowerStringType) semanticObject); 
				return; 
			case MutatorenvironmentPackage.MAX_VALUE_TYPE:
				sequence_MaxValueType(context, (MaxValueType) semanticObject); 
				return; 
			case MutatorenvironmentPackage.MIN_VALUE_TYPE:
				sequence_MinValueType(context, (MinValueType) semanticObject); 
				return; 
			case MutatorenvironmentPackage.MODIFY_INFORMATION_MUTATOR:
				sequence_ModifyInformationMutator(context, (ModifyInformationMutator) semanticObject); 
				return; 
			case MutatorenvironmentPackage.MODIFY_SOURCE_REFERENCE_MUTATOR:
				sequence_ModifySourceReferenceMutator(context, (ModifySourceReferenceMutator) semanticObject); 
				return; 
			case MutatorenvironmentPackage.MODIFY_TARGET_REFERENCE_MUTATOR:
				sequence_ModifyTargetReferenceMutator(context, (ModifyTargetReferenceMutator) semanticObject); 
				return; 
			case MutatorenvironmentPackage.MUTATOR_ENVIRONMENT:
				sequence_MutatorEnvironment(context, (MutatorEnvironment) semanticObject); 
				return; 
			case MutatorenvironmentPackage.OBJECT_ATTRIBUTE_TYPE:
				sequence_ObjectAttributeType(context, (ObjectAttributeType) semanticObject); 
				return; 
			case MutatorenvironmentPackage.OTHER_TYPE_SELECTION:
				sequence_OtherTypeSelection(context, (OtherTypeSelection) semanticObject); 
				return; 
			case MutatorenvironmentPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case MutatorenvironmentPackage.RANDOM_BOOLEAN_TYPE:
				sequence_RandomBooleanType(context, (RandomBooleanType) semanticObject); 
				return; 
			case MutatorenvironmentPackage.RANDOM_DOUBLE_NUMBER_TYPE:
				sequence_RandomDoubleNumberType(context, (RandomDoubleNumberType) semanticObject); 
				return; 
			case MutatorenvironmentPackage.RANDOM_DOUBLE_TYPE:
				sequence_RandomDoubleType(context, (RandomDoubleType) semanticObject); 
				return; 
			case MutatorenvironmentPackage.RANDOM_INTEGER_NUMBER_TYPE:
				sequence_RandomIntegerNumberType(context, (RandomIntegerNumberType) semanticObject); 
				return; 
			case MutatorenvironmentPackage.RANDOM_INTEGER_TYPE:
				sequence_RandomIntegerType(context, (RandomIntegerType) semanticObject); 
				return; 
			case MutatorenvironmentPackage.RANDOM_STRING_NUMBER_TYPE:
				sequence_RandomStringNumberType(context, (RandomStringNumberType) semanticObject); 
				return; 
			case MutatorenvironmentPackage.RANDOM_STRING_TYPE:
				sequence_RandomStringType(context, (RandomStringType) semanticObject); 
				return; 
			case MutatorenvironmentPackage.RANDOM_TYPE:
				sequence_RandomType(context, (RandomType) semanticObject); 
				return; 
			case MutatorenvironmentPackage.RANDOM_TYPE_SELECTION:
				sequence_RandomTypeSelection(context, (RandomTypeSelection) semanticObject); 
				return; 
			case MutatorenvironmentPackage.REFERENCE_ADD:
				sequence_ReferenceAdd(context, (ReferenceAdd) semanticObject); 
				return; 
			case MutatorenvironmentPackage.REFERENCE_ATT:
				sequence_ReferenceAtt(context, (ReferenceAtt) semanticObject); 
				return; 
			case MutatorenvironmentPackage.REFERENCE_EVALUATION:
				sequence_ReferenceEvaluation(context, (ReferenceEvaluation) semanticObject); 
				return; 
			case MutatorenvironmentPackage.REFERENCE_INIT:
				sequence_ReferenceInit(context, (ReferenceInit) semanticObject); 
				return; 
			case MutatorenvironmentPackage.REFERENCE_REMOVE:
				sequence_ReferenceRemove(context, (ReferenceRemove) semanticObject); 
				return; 
			case MutatorenvironmentPackage.REFERENCE_SWAP:
				sequence_ReferenceSwap(context, (ReferenceSwap) semanticObject); 
				return; 
			case MutatorenvironmentPackage.REMOVE_COMPLETE_REFERENCE_MUTATOR:
				sequence_RemoveCompleteReferenceMutator(context, (RemoveCompleteReferenceMutator) semanticObject); 
				return; 
			case MutatorenvironmentPackage.REMOVE_OBJECT_MUTATOR:
				sequence_RemoveObjectMutator(context, (RemoveObjectMutator) semanticObject); 
				return; 
			case MutatorenvironmentPackage.REMOVE_RANDOM_REFERENCE_MUTATOR:
				sequence_RemoveRandomReferenceMutator(context, (RemoveRandomReferenceMutator) semanticObject); 
				return; 
			case MutatorenvironmentPackage.REMOVE_SPECIFIC_REFERENCE_MUTATOR:
				sequence_RemoveSpecificReferenceMutator(context, (RemoveSpecificReferenceMutator) semanticObject); 
				return; 
			case MutatorenvironmentPackage.REPLACE_STRING_TYPE:
				sequence_ReplaceStringType(context, (ReplaceStringType) semanticObject); 
				return; 
			case MutatorenvironmentPackage.RESOURCE:
				sequence_Resource(context, (Resource) semanticObject); 
				return; 
			case MutatorenvironmentPackage.RETYPE_OBJECT_MUTATOR:
				sequence_RetypeObjectMutator(context, (RetypeObjectMutator) semanticObject); 
				return; 
			case MutatorenvironmentPackage.SELECT_OBJECT_MUTATOR:
				sequence_SelectObjectMutator(context, (SelectObjectMutator) semanticObject); 
				return; 
			case MutatorenvironmentPackage.SELECT_SAMPLE_MUTATOR:
				sequence_SelectSampleMutator(context, (SelectSampleMutator) semanticObject); 
				return; 
			case MutatorenvironmentPackage.SOURCE:
				sequence_Source(context, (Source) semanticObject); 
				return; 
			case MutatorenvironmentPackage.SPECIFIC_BOOLEAN_TYPE:
				sequence_SpecificBooleanType(context, (SpecificBooleanType) semanticObject); 
				return; 
			case MutatorenvironmentPackage.SPECIFIC_CLOSURE_SELECTION:
				sequence_SpecificClosureSelection(context, (SpecificClosureSelection) semanticObject); 
				return; 
			case MutatorenvironmentPackage.SPECIFIC_DOUBLE_TYPE:
				sequence_SpecificDoubleType(context, (SpecificDoubleType) semanticObject); 
				return; 
			case MutatorenvironmentPackage.SPECIFIC_INTEGER_TYPE:
				sequence_SpecificIntegerType(context, (SpecificIntegerType) semanticObject); 
				return; 
			case MutatorenvironmentPackage.SPECIFIC_OBJECT_SELECTION:
				sequence_SpecificObjectSelection(context, (SpecificObjectSelection) semanticObject); 
				return; 
			case MutatorenvironmentPackage.SPECIFIC_STRING_TYPE:
				sequence_SpecificStringType(context, (SpecificStringType) semanticObject); 
				return; 
			case MutatorenvironmentPackage.TYPED_SELECTION:
				sequence_TypedSelection(context, (TypedSelection) semanticObject); 
				return; 
			case MutatorenvironmentPackage.UPPER_STRING_TYPE:
				sequence_UpperStringType(context, (UpperStringType) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     AccVarCS returns AccVarCS
	 *
	 * Constraint:
	 *     (accVarName=ID accType=PathNameCS? accInitExp=ExpCS?)
	 * </pre>
	 */
	protected void sequence_AccVarCS(ISerializationContext context, AccVarCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeSet returns AttributeCopy
	 *     AttributeCopy returns AttributeCopy
	 *
	 * Constraint:
	 *     (attribute+=[EAttribute|ID] object=ObSelectionStrategy? attribute+=[EAttribute|ID])
	 * </pre>
	 */
	protected void sequence_AttributeCopy(ISerializationContext context, AttributeCopy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeEvaluation returns AttributeEvaluation
	 *     Evaluation returns AttributeEvaluation
	 *
	 * Constraint:
	 *     (name=[EAttribute|ID] value=AttributeEvaluationType)
	 * </pre>
	 */
	protected void sequence_AttributeEvaluation(ISerializationContext context, AttributeEvaluation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.ATTRIBUTE_EVALUATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.ATTRIBUTE_EVALUATION__NAME));
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.ATTRIBUTE_EVALUATION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.ATTRIBUTE_EVALUATION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeEvaluationAccess().getNameEAttributeIDTerminalRuleCall_1_0_1(), semanticObject.eGet(MutatorenvironmentPackage.Literals.ATTRIBUTE_EVALUATION__NAME, false));
		feeder.accept(grammarAccess.getAttributeEvaluationAccess().getValueAttributeEvaluationTypeParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeSet returns AttributeOperation
	 *     AttributeOperation returns AttributeOperation
	 *
	 * Constraint:
	 *     (attribute+=[EAttribute|ID] operator=ArithmeticOperator value=AttributeEvaluationType)
	 * </pre>
	 */
	protected void sequence_AttributeOperation(ISerializationContext context, AttributeOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeSet returns AttributeReverse
	 *     AttributeReverse returns AttributeReverse
	 *
	 * Constraint:
	 *     attribute+=[EAttribute|ID]
	 * </pre>
	 */
	protected void sequence_AttributeReverse(ISerializationContext context, AttributeReverse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeSet returns AttributeScalar
	 *     AttributeScalar returns AttributeScalar
	 *
	 * Constraint:
	 *     (attribute+=[EAttribute|ID] value=AttributeType)
	 * </pre>
	 */
	protected void sequence_AttributeScalar(ISerializationContext context, AttributeScalar semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeSet returns AttributeSwap
	 *     AttributeSwap returns AttributeSwap
	 *
	 * Constraint:
	 *     (attribute+=[EAttribute|ID] object=ObSelectionStrategy? attribute+=[EAttribute|ID])
	 * </pre>
	 */
	protected void sequence_AttributeSwap(ISerializationContext context, AttributeSwap semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeSet returns AttributeUnset
	 *     AttributeUnset returns AttributeUnset
	 *
	 * Constraint:
	 *     attribute+=[EAttribute|ID]
	 * </pre>
	 */
	protected void sequence_AttributeUnset(ISerializationContext context, AttributeUnset semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BinaryOperator returns BinaryOperator
	 *
	 * Constraint:
	 *     type=LogicOperator
	 * </pre>
	 */
	protected void sequence_BinaryOperator(ISerializationContext context, BinaryOperator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.BINARY_OPERATOR__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.BINARY_OPERATOR__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBinaryOperatorAccess().getTypeLogicOperatorEnumRuleCall_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Block returns Block
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         description=EString? 
	 *         (from+=[Block|ID] from+=[Block|ID]*)? 
	 *         repeat=Repeat? 
	 *         commands+=Mutator* 
	 *         ((min=EInt max=MaxCardinality) | fixed=EInt)?
	 *     )
	 * </pre>
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExpCS returns BooleanExpCS
	 *     LogicExpCS returns BooleanExpCS
	 *     LogicExpCS.LogicExpCS_1_0 returns BooleanExpCS
	 *     CallExpCS returns BooleanExpCS
	 *     CallExpCS.CallExpCS_1_0 returns BooleanExpCS
	 *     PrimaryExpCS returns BooleanExpCS
	 *     LiteralExpCS returns BooleanExpCS
	 *     BooleanLiteralExpCS returns BooleanExpCS
	 *
	 * Constraint:
	 *     boolSymbol?='true'?
	 * </pre>
	 */
	protected void sequence_BooleanLiteralExpCS(ISerializationContext context, BooleanExpCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExpCS returns CallExpCS
	 *     LogicExpCS returns CallExpCS
	 *     LogicExpCS.LogicExpCS_1_0 returns CallExpCS
	 *     CallExpCS returns CallExpCS
	 *     CallExpCS.CallExpCS_1_0 returns CallExpCS
	 *
	 * Constraint:
	 *     (source=CallExpCS_CallExpCS_1_0 (op='.' | op='-&gt;') navExp=NavigationExpCS)
	 * </pre>
	 */
	protected void sequence_CallExpCS(ISerializationContext context, CallExpCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeEvaluationType returns CatEndStringType
	 *     AttributeType returns CatEndStringType
	 *     StringType returns CatEndStringType
	 *     CatEndStringType returns CatEndStringType
	 *
	 * Constraint:
	 *     (operator=Operator value=EString)
	 * </pre>
	 */
	protected void sequence_CatEndStringType(ISerializationContext context, CatEndStringType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.ATTRIBUTE_TYPE__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.ATTRIBUTE_TYPE__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.CAT_END_STRING_TYPE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.CAT_END_STRING_TYPE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCatEndStringTypeAccess().getOperatorOperatorEnumRuleCall_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getCatEndStringTypeAccess().getValueEStringParserRuleCall_4_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeEvaluationType returns CatStartStringType
	 *     AttributeType returns CatStartStringType
	 *     StringType returns CatStartStringType
	 *     CatStartStringType returns CatStartStringType
	 *
	 * Constraint:
	 *     (operator=Operator value=EString)
	 * </pre>
	 */
	protected void sequence_CatStartStringType(ISerializationContext context, CatStartStringType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.ATTRIBUTE_TYPE__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.ATTRIBUTE_TYPE__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.CAT_START_STRING_TYPE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.CAT_START_STRING_TYPE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCatStartStringTypeAccess().getOperatorOperatorEnumRuleCall_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getCatStartStringTypeAccess().getValueEStringParserRuleCall_4_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Mutator returns CloneObjectMutator
	 *     CloneObjectMutator returns CloneObjectMutator
	 *
	 * Constraint:
	 *     (
	 *         name=ID? 
	 *         contents?='deep'? 
	 *         object=ObSelectionStrategy 
	 *         container=ObSelectionStrategy? 
	 *         (attributes+=AttributeSet | references+=ReferenceSet)? 
	 *         attributes+=AttributeSet? 
	 *         (references+=ReferenceSet? attributes+=AttributeSet?)* 
	 *         (min=EInt? max=MaxCardinality)?
	 *     )
	 * </pre>
	 */
	protected void sequence_CloneObjectMutator(ISerializationContext context, CloneObjectMutator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NavigationExpCS returns CollectExpCS
	 *     LoopExpCS returns CollectExpCS
	 *     CollectExpCS returns CollectExpCS
	 *
	 * Constraint:
	 *     (itVar=IteratorVarCS? exp+=ExpCS ((logicOp+='or' | logicOp+='and') exp+=ExpCS)*)
	 * </pre>
	 */
	protected void sequence_CollectExpCS(ISerializationContext context, CollectExpCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ObSelectionStrategy returns CompleteTypeSelection
	 *     CompleteSelection returns CompleteTypeSelection
	 *     CompleteTypeSelection returns CompleteTypeSelection
	 *
	 * Constraint:
	 *     (
	 *         (type=[EClass|ID] | (types+=[EClass|ID] types+=[EClass|ID]*)) 
	 *         (refType=[EReference|ID] (refRefType=[EReference|ID] refRefRefType=[EReference|ID]?)?)? 
	 *         expression=Expression?
	 *     )
	 * </pre>
	 */
	protected void sequence_CompleteTypeSelection(ISerializationContext context, CompleteTypeSelection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Mutator returns CompositeMutator
	 *     CompositeMutator returns CompositeMutator
	 *
	 * Constraint:
	 *     (name=ID? commands+=Mutator commands+=Mutator* ((min=EInt max=MaxCardinality) | fixed=EInt)?)
	 * </pre>
	 */
	protected void sequence_CompositeMutator(ISerializationContext context, CompositeMutator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Constraint returns Constraint
	 *
	 * Constraint:
	 *     (type=[EClass|ID] id=EString (expressions+=InvariantCS+ | rules+=EString+))
	 * </pre>
	 */
	protected void sequence_Constraint(ISerializationContext context, Constraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Mutator returns CreateObjectMutator
	 *     CreateObjectMutator returns CreateObjectMutator
	 *
	 * Constraint:
	 *     (
	 *         name=ID? 
	 *         type=[EClass|ID] 
	 *         container=ObSelectionStrategy? 
	 *         (attributes+=AttributeSet | references+=ReferenceSet)? 
	 *         attributes+=AttributeSet? 
	 *         (references+=ReferenceSet? attributes+=AttributeSet?)* 
	 *         (min=EInt? max=MaxCardinality)?
	 *     )
	 * </pre>
	 */
	protected void sequence_CreateObjectMutator(ISerializationContext context, CreateObjectMutator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Mutator returns CreateReferenceMutator
	 *     CreateReferenceMutator returns CreateReferenceMutator
	 *
	 * Constraint:
	 *     (name=ID? refType=[EReference|ID] target=ObSelectionStrategy? source=ObSelectionStrategy? (min=EInt? max=MaxCardinality)?)
	 * </pre>
	 */
	protected void sequence_CreateReferenceMutator(ISerializationContext context, CreateReferenceMutator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NavigationExpCS returns ExistsExpCS
	 *     LoopExpCS returns ExistsExpCS
	 *     ExistsExpCS returns ExistsExpCS
	 *
	 * Constraint:
	 *     (accVars+=AccVarCS accVars+=AccVarCS* exp+=ExpCS ((logicOp+='or' | logicOp+='and') exp+=ExpCS)*)
	 * </pre>
	 */
	protected void sequence_ExistsExpCS(ISerializationContext context, ExistsExpCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Expression
	 *
	 * Constraint:
	 *     (first=Evaluation (operator+=BinaryOperator second+=Evaluation)*)
	 * </pre>
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NavigationExpCS returns ForAllExpCS
	 *     LoopExpCS returns ForAllExpCS
	 *     ForAllExpCS returns ForAllExpCS
	 *
	 * Constraint:
	 *     (accVars+=AccVarCS accVars+=AccVarCS* exp+=ExpCS ((logicOp+='or' | logicOp+='and') exp+=ExpCS)*)
	 * </pre>
	 */
	protected void sequence_ForAllExpCS(ISerializationContext context, ForAllExpCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExpCS returns IntLiteralExpCS
	 *     LogicExpCS returns IntLiteralExpCS
	 *     LogicExpCS.LogicExpCS_1_0 returns IntLiteralExpCS
	 *     CallExpCS returns IntLiteralExpCS
	 *     CallExpCS.CallExpCS_1_0 returns IntLiteralExpCS
	 *     PrimaryExpCS returns IntLiteralExpCS
	 *     LiteralExpCS returns IntLiteralExpCS
	 *     IntLiteralExpCS returns IntLiteralExpCS
	 *
	 * Constraint:
	 *     intSymbol=INT
	 * </pre>
	 */
	protected void sequence_IntLiteralExpCS(ISerializationContext context, IntLiteralExpCS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniOCLPackage.Literals.INT_LITERAL_EXP_CS__INT_SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniOCLPackage.Literals.INT_LITERAL_EXP_CS__INT_SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntLiteralExpCSAccess().getIntSymbolINTTerminalRuleCall_0(), semanticObject.getIntSymbol());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InvariantCS returns InvariantCS
	 *
	 * Constraint:
	 *     exp=ExpCS
	 * </pre>
	 */
	protected void sequence_InvariantCS(ISerializationContext context, InvariantCS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniOCLPackage.Literals.INVARIANT_CS__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniOCLPackage.Literals.INVARIANT_CS__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInvariantCSAccess().getExpExpCSParserRuleCall_0_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NavigationExpCS returns IterateExpCS
	 *     LoopExpCS returns IterateExpCS
	 *     IterateExpCS returns IterateExpCS
	 *
	 * Constraint:
	 *     (itVar=IteratorVarCS accVar=AccVarCS exp+=ExpCS ((logicOp+='or' | logicOp+='and') exp+=ExpCS)*)
	 * </pre>
	 */
	protected void sequence_IterateExpCS(ISerializationContext context, IterateExpCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IteratorVarCS returns IteratorVarCS
	 *
	 * Constraint:
	 *     (itName=ID itType=PathNameCS?)
	 * </pre>
	 */
	protected void sequence_IteratorVarCS(ISerializationContext context, IteratorVarCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Definition returns Library
	 *     Library returns Library
	 *
	 * Constraint:
	 *     metamodel=EString
	 * </pre>
	 */
	protected void sequence_Library(ISerializationContext context, Library semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.DEFINITION__METAMODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.DEFINITION__METAMODEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLibraryAccess().getMetamodelEStringParserRuleCall_4_0(), semanticObject.getMetamodel());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeEvaluationType returns ListStringType
	 *     AttributeType returns ListStringType
	 *     ListStringType returns ListStringType
	 *
	 * Constraint:
	 *     (operator=Operator value+=EString value+=EString*)
	 * </pre>
	 */
	protected void sequence_ListStringType(ISerializationContext context, ListStringType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeEvaluationType returns ListType
	 *     AttributeType returns ListType
	 *     ListType returns ListType
	 *
	 * Constraint:
	 *     (operator=Operator value+=[EObject|ID] value+=[EObject|ID]*)
	 * </pre>
	 */
	protected void sequence_ListType(ISerializationContext context, ListType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Load returns Load
	 *
	 * Constraint:
	 *     file=EString
	 * </pre>
	 */
	protected void sequence_Load(ISerializationContext context, Load semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.LOAD__FILE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.LOAD__FILE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLoadAccess().getFileEStringParserRuleCall_2_0(), semanticObject.getFile());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExpCS returns LogicExpCS
	 *     LogicExpCS returns LogicExpCS
	 *     LogicExpCS.LogicExpCS_1_0 returns LogicExpCS
	 *
	 * Constraint:
	 *     (left=LogicExpCS_LogicExpCS_1_0 (op='=' | op='&lt;&gt;') right=CallExpCS)
	 * </pre>
	 */
	protected void sequence_LogicExpCS(ISerializationContext context, LogicExpCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeEvaluationType returns LowerStringType
	 *     AttributeType returns LowerStringType
	 *     StringType returns LowerStringType
	 *     LowerStringType returns LowerStringType
	 *
	 * Constraint:
	 *     operator=Operator
	 * </pre>
	 */
	protected void sequence_LowerStringType(ISerializationContext context, LowerStringType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.ATTRIBUTE_TYPE__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.ATTRIBUTE_TYPE__OPERATOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLowerStringTypeAccess().getOperatorOperatorEnumRuleCall_1_0(), semanticObject.getOperator());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeEvaluationType returns MaxValueType
	 *     AttributeType returns MaxValueType
	 *     NumberType returns MaxValueType
	 *     MaxValueType returns MaxValueType
	 *
	 * Constraint:
	 *     (operator=Operator attribute=[EAttribute|ID])
	 * </pre>
	 */
	protected void sequence_MaxValueType(ISerializationContext context, MaxValueType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.ATTRIBUTE_TYPE__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.ATTRIBUTE_TYPE__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.MAX_VALUE_TYPE__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.MAX_VALUE_TYPE__ATTRIBUTE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMaxValueTypeAccess().getOperatorOperatorEnumRuleCall_0_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getMaxValueTypeAccess().getAttributeEAttributeIDTerminalRuleCall_3_0_1(), semanticObject.eGet(MutatorenvironmentPackage.Literals.MAX_VALUE_TYPE__ATTRIBUTE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeEvaluationType returns MinValueType
	 *     AttributeType returns MinValueType
	 *     NumberType returns MinValueType
	 *     MinValueType returns MinValueType
	 *
	 * Constraint:
	 *     (operator=Operator attribute=[EAttribute|ID])
	 * </pre>
	 */
	protected void sequence_MinValueType(ISerializationContext context, MinValueType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.ATTRIBUTE_TYPE__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.ATTRIBUTE_TYPE__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.MIN_VALUE_TYPE__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.MIN_VALUE_TYPE__ATTRIBUTE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMinValueTypeAccess().getOperatorOperatorEnumRuleCall_0_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getMinValueTypeAccess().getAttributeEAttributeIDTerminalRuleCall_3_0_1(), semanticObject.eGet(MutatorenvironmentPackage.Literals.MIN_VALUE_TYPE__ATTRIBUTE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Mutator returns ModifyInformationMutator
	 *     ModifyInformationMutator returns ModifyInformationMutator
	 *
	 * Constraint:
	 *     (
	 *         name=ID? 
	 *         object=ObSelectionStrategy 
	 *         (attributes+=AttributeSet | references+=ReferenceSet)? 
	 *         attributes+=AttributeSet? 
	 *         (references+=ReferenceSet? attributes+=AttributeSet?)* 
	 *         (min=EInt? max=MaxCardinality)?
	 *     )
	 * </pre>
	 */
	protected void sequence_ModifyInformationMutator(ISerializationContext context, ModifyInformationMutator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Mutator returns ModifySourceReferenceMutator
	 *     ModifySourceReferenceMutator returns ModifySourceReferenceMutator
	 *
	 * Constraint:
	 *     (refType=[EReference|ID] source=ObSelectionStrategy? newSource=ObSelectionStrategy? (min=EInt? max=MaxCardinality)?)
	 * </pre>
	 */
	protected void sequence_ModifySourceReferenceMutator(ISerializationContext context, ModifySourceReferenceMutator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Mutator returns ModifyTargetReferenceMutator
	 *     ModifyTargetReferenceMutator returns ModifyTargetReferenceMutator
	 *
	 * Constraint:
	 *     (refType=[EReference|ID] source=ObSelectionStrategy? newTarget=ObSelectionStrategy? (min=EInt? max=MaxCardinality)?)
	 * </pre>
	 */
	protected void sequence_ModifyTargetReferenceMutator(ISerializationContext context, ModifyTargetReferenceMutator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MutatorEnvironment returns MutatorEnvironment
	 *
	 * Constraint:
	 *     (load+=Load* definition=Definition (blocks+=Block+ | commands+=Mutator+)? constraints+=Constraint*)
	 * </pre>
	 */
	protected void sequence_MutatorEnvironment(ISerializationContext context, MutatorEnvironment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExpCS returns NameExpCS
	 *     LogicExpCS returns NameExpCS
	 *     LogicExpCS.LogicExpCS_1_0 returns NameExpCS
	 *     CallExpCS returns NameExpCS
	 *     CallExpCS.CallExpCS_1_0 returns NameExpCS
	 *     PrimaryExpCS returns NameExpCS
	 *     NameExpCS returns NameExpCS
	 *
	 * Constraint:
	 *     (expName=PathNameCS roundedBrackets=RoundedBracketClauseCS? callExp=CallExpCS?)
	 * </pre>
	 */
	protected void sequence_NameExpCS(ISerializationContext context, NameExpCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NavigationExpCS returns NavigationNameExpCS
	 *     NavigationNameExpCS returns NavigationNameExpCS
	 *
	 * Constraint:
	 *     (expName=NavigationPathNameCS roundedBrackets=RoundedBracketClauseCS? callExp=CallExpCS?)
	 * </pre>
	 */
	protected void sequence_NavigationNameExpCS(ISerializationContext context, NavigationNameExpCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NavigationPathCS returns NavigationPathElementCS
	 *     NavigationPathElementCS returns NavigationPathElementCS
	 *
	 * Constraint:
	 *     pathName=[EStructuralFeature|ID]
	 * </pre>
	 */
	protected void sequence_NavigationPathElementCS(ISerializationContext context, NavigationPathElementCS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniOCLPackage.Literals.NAVIGATION_PATH_ELEMENT_CS__PATH_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniOCLPackage.Literals.NAVIGATION_PATH_ELEMENT_CS__PATH_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNavigationPathElementCSAccess().getPathNameEStructuralFeatureIDTerminalRuleCall_0_1(), semanticObject.eGet(MiniOCLPackage.Literals.NAVIGATION_PATH_ELEMENT_CS__PATH_NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NavigationPathNameCS returns NavigationPathNameCS
	 *
	 * Constraint:
	 *     (path+=NavigationPathCS path+=NavigationPathCS*)
	 * </pre>
	 */
	protected void sequence_NavigationPathNameCS(ISerializationContext context, NavigationPathNameCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NavigationPathCS returns NavigationPathVariableCS
	 *     NavigationPathVariableCS returns NavigationPathVariableCS
	 *
	 * Constraint:
	 *     varName=EString
	 * </pre>
	 */
	protected void sequence_NavigationPathVariableCS(ISerializationContext context, NavigationPathVariableCS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniOCLPackage.Literals.NAVIGATION_PATH_VARIABLE_CS__VAR_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniOCLPackage.Literals.NAVIGATION_PATH_VARIABLE_CS__VAR_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNavigationPathVariableCSAccess().getVarNameEStringParserRuleCall_1_0(), semanticObject.getVarName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeEvaluationType returns ObjectAttributeType
	 *     ObjectAttributeType returns ObjectAttributeType
	 *
	 * Constraint:
	 *     (operator=Operator objSel=[ObjectEmitter|ID] attribute=[EAttribute|ID])
	 * </pre>
	 */
	protected void sequence_ObjectAttributeType(ISerializationContext context, ObjectAttributeType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.OBJECT_ATTRIBUTE_TYPE__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.OBJECT_ATTRIBUTE_TYPE__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.OBJECT_ATTRIBUTE_TYPE__OBJ_SEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.OBJECT_ATTRIBUTE_TYPE__OBJ_SEL));
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.OBJECT_ATTRIBUTE_TYPE__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.OBJECT_ATTRIBUTE_TYPE__ATTRIBUTE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObjectAttributeTypeAccess().getOperatorOperatorEnumRuleCall_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getObjectAttributeTypeAccess().getObjSelObjectEmitterIDTerminalRuleCall_2_0_1(), semanticObject.eGet(MutatorenvironmentPackage.Literals.OBJECT_ATTRIBUTE_TYPE__OBJ_SEL, false));
		feeder.accept(grammarAccess.getObjectAttributeTypeAccess().getAttributeEAttributeIDTerminalRuleCall_4_0_1(), semanticObject.eGet(MutatorenvironmentPackage.Literals.OBJECT_ATTRIBUTE_TYPE__ATTRIBUTE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ObSelectionStrategy returns OtherTypeSelection
	 *     OtherSelection returns OtherTypeSelection
	 *     OtherTypeSelection returns OtherTypeSelection
	 *
	 * Constraint:
	 *     (
	 *         (type=[EClass|ID] | (types+=[EClass|ID] types+=[EClass|ID]*)) 
	 *         (refType=[EReference|ID] (refRefType=[EReference|ID] refRefRefType=[EReference|ID]?)?)? 
	 *         expression=Expression?
	 *     )
	 * </pre>
	 */
	protected void sequence_OtherTypeSelection(ISerializationContext context, OtherTypeSelection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PathCS returns PathElementCS
	 *     PathElementCS returns PathElementCS
	 *
	 * Constraint:
	 *     pathName=[EStructuralFeature|ID]
	 * </pre>
	 */
	protected void sequence_PathElementCS(ISerializationContext context, PathElementCS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniOCLPackage.Literals.PATH_ELEMENT_CS__PATH_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniOCLPackage.Literals.PATH_ELEMENT_CS__PATH_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPathElementCSAccess().getPathNameEStructuralFeatureIDTerminalRuleCall_0_1(), semanticObject.eGet(MiniOCLPackage.Literals.PATH_ELEMENT_CS__PATH_NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PathNameCS returns PathNameCS
	 *
	 * Constraint:
	 *     (path+=PathCS path+=PathCS*)
	 * </pre>
	 */
	protected void sequence_PathNameCS(ISerializationContext context, PathNameCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PathCS returns PathVariableCS
	 *     PathVariableCS returns PathVariableCS
	 *
	 * Constraint:
	 *     varName=EString
	 * </pre>
	 */
	protected void sequence_PathVariableCS(ISerializationContext context, PathVariableCS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniOCLPackage.Literals.PATH_VARIABLE_CS__VAR_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniOCLPackage.Literals.PATH_VARIABLE_CS__VAR_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPathVariableCSAccess().getVarNameEStringParserRuleCall_1_0(), semanticObject.getVarName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Definition returns Program
	 *     Program returns Program
	 *
	 * Constraint:
	 *     (
	 *         (num=EInt | exhaustive?='exhaustive')? 
	 *         output=EString 
	 *         source=Source 
	 *         metamodel=EString 
	 *         (resources+=Resource resources+=Resource*)? 
	 *         description=EString?
	 *     )
	 * </pre>
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeEvaluationType returns RandomBooleanType
	 *     AttributeType returns RandomBooleanType
	 *     BooleanType returns RandomBooleanType
	 *     RandomBooleanType returns RandomBooleanType
	 *
	 * Constraint:
	 *     operator=Operator
	 * </pre>
	 */
	protected void sequence_RandomBooleanType(ISerializationContext context, RandomBooleanType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.ATTRIBUTE_TYPE__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.ATTRIBUTE_TYPE__OPERATOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRandomBooleanTypeAccess().getOperatorOperatorEnumRuleCall_1_0(), semanticObject.getOperator());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeEvaluationType returns RandomDoubleNumberType
	 *     AttributeType returns RandomDoubleNumberType
	 *     NumberType returns RandomDoubleNumberType
	 *     RandomNumberType returns RandomDoubleNumberType
	 *     RandomDoubleNumberType returns RandomDoubleNumberType
	 *
	 * Constraint:
	 *     (operator=Operator min=EDouble object=ObSelectionStrategy? max=[EAttribute|ID])
	 * </pre>
	 */
	protected void sequence_RandomDoubleNumberType(ISerializationContext context, RandomDoubleNumberType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeEvaluationType returns RandomDoubleType
	 *     AttributeType returns RandomDoubleType
	 *     NumberType returns RandomDoubleType
	 *     DoubleType returns RandomDoubleType
	 *     RandomDoubleType returns RandomDoubleType
	 *
	 * Constraint:
	 *     (operator=Operator (min=EDouble max=EDouble)?)
	 * </pre>
	 */
	protected void sequence_RandomDoubleType(ISerializationContext context, RandomDoubleType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeEvaluationType returns RandomIntegerNumberType
	 *     AttributeType returns RandomIntegerNumberType
	 *     NumberType returns RandomIntegerNumberType
	 *     RandomNumberType returns RandomIntegerNumberType
	 *     RandomIntegerNumberType returns RandomIntegerNumberType
	 *
	 * Constraint:
	 *     (operator=Operator min=EInt object=ObSelectionStrategy? max=[EAttribute|ID])
	 * </pre>
	 */
	protected void sequence_RandomIntegerNumberType(ISerializationContext context, RandomIntegerNumberType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeEvaluationType returns RandomIntegerType
	 *     AttributeType returns RandomIntegerType
	 *     NumberType returns RandomIntegerType
	 *     IntegerType returns RandomIntegerType
	 *     RandomIntegerType returns RandomIntegerType
	 *
	 * Constraint:
	 *     (operator=Operator (min=EInt max=EInt)?)
	 * </pre>
	 */
	protected void sequence_RandomIntegerType(ISerializationContext context, RandomIntegerType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeEvaluationType returns RandomStringNumberType
	 *     AttributeType returns RandomStringNumberType
	 *     StringType returns RandomStringNumberType
	 *     RandomStringNumberType returns RandomStringNumberType
	 *
	 * Constraint:
	 *     (operator=Operator (min=EInt max=EInt)?)
	 * </pre>
	 */
	protected void sequence_RandomStringNumberType(ISerializationContext context, RandomStringNumberType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeEvaluationType returns RandomStringType
	 *     AttributeType returns RandomStringType
	 *     StringType returns RandomStringType
	 *     RandomStringType returns RandomStringType
	 *
	 * Constraint:
	 *     (operator=Operator min=EInt max=EInt)
	 * </pre>
	 */
	protected void sequence_RandomStringType(ISerializationContext context, RandomStringType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.ATTRIBUTE_TYPE__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.ATTRIBUTE_TYPE__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.RANDOM_STRING_TYPE__MIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.RANDOM_STRING_TYPE__MIN));
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.RANDOM_STRING_TYPE__MAX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.RANDOM_STRING_TYPE__MAX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRandomStringTypeAccess().getOperatorOperatorEnumRuleCall_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getRandomStringTypeAccess().getMinEIntParserRuleCall_4_0(), semanticObject.getMin());
		feeder.accept(grammarAccess.getRandomStringTypeAccess().getMaxEIntParserRuleCall_6_0(), semanticObject.getMax());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ObSelectionStrategy returns RandomTypeSelection
	 *     RandomSelection returns RandomTypeSelection
	 *     RandomTypeSelection returns RandomTypeSelection
	 *
	 * Constraint:
	 *     (
	 *         (type=[EClass|ID] | (types+=[EClass|ID] types+=[EClass|ID]*)) 
	 *         (refType=[EReference|ID] (refRefType=[EReference|ID] refRefRefType=[EReference|ID]?)?)? 
	 *         resource=ID? 
	 *         expression=Expression?
	 *     )
	 * </pre>
	 */
	protected void sequence_RandomTypeSelection(ISerializationContext context, RandomTypeSelection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeEvaluationType returns RandomType
	 *     AttributeType returns RandomType
	 *     RandomType returns RandomType
	 *
	 * Constraint:
	 *     operator=Operator
	 * </pre>
	 */
	protected void sequence_RandomType(ISerializationContext context, RandomType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.ATTRIBUTE_TYPE__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.ATTRIBUTE_TYPE__OPERATOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRandomTypeAccess().getOperatorOperatorEnumRuleCall_1_0(), semanticObject.getOperator());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReferenceSet returns ReferenceAdd
	 *     ReferenceAdd returns ReferenceAdd
	 *
	 * Constraint:
	 *     (reference+=[EReference|ID] object=ObSelectionStrategy)
	 * </pre>
	 */
	protected void sequence_ReferenceAdd(ISerializationContext context, ReferenceAdd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReferenceSet returns ReferenceAtt
	 *     ReferenceAtt returns ReferenceAtt
	 *
	 * Constraint:
	 *     (reference+=[EReference|ID] attribute=[EAttribute|ID] value=AttributeType)
	 * </pre>
	 */
	protected void sequence_ReferenceAtt(ISerializationContext context, ReferenceAtt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReferenceEvaluation returns ReferenceEvaluation
	 *     Evaluation returns ReferenceEvaluation
	 *
	 * Constraint:
	 *     (
	 *         (name=[EReference|ID] | self?='self' | container?='container') 
	 *         ((attName=[EAttribute|ID] attValue=AttributeEvaluationType) | (refName=[EReference|ID] refRefName=[EReference|ID]?))? 
	 *         operator=Operator 
	 *         value=ObSelectionStrategy?
	 *     )
	 * </pre>
	 */
	protected void sequence_ReferenceEvaluation(ISerializationContext context, ReferenceEvaluation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReferenceSet returns ReferenceInit
	 *     ReferenceInit returns ReferenceInit
	 *
	 * Constraint:
	 *     (reference+=[EReference|ID] object=ObSelectionStrategy)
	 * </pre>
	 */
	protected void sequence_ReferenceInit(ISerializationContext context, ReferenceInit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReferenceSet returns ReferenceRemove
	 *     ReferenceRemove returns ReferenceRemove
	 *
	 * Constraint:
	 *     (reference+=[EReference|ID] object=ObSelectionStrategy)
	 * </pre>
	 */
	protected void sequence_ReferenceRemove(ISerializationContext context, ReferenceRemove semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReferenceSet returns ReferenceSwap
	 *     ReferenceSwap returns ReferenceSwap
	 *
	 * Constraint:
	 *     (reference+=[EReference|ID] object=ObSelectionStrategy? reference+=[EReference|ID])
	 * </pre>
	 */
	protected void sequence_ReferenceSwap(ISerializationContext context, ReferenceSwap semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Mutator returns RemoveCompleteReferenceMutator
	 *     RemoveReferenceMutator returns RemoveCompleteReferenceMutator
	 *     RemoveCompleteReferenceMutator returns RemoveCompleteReferenceMutator
	 *
	 * Constraint:
	 *     (refType=[EReference|ID] type=[EClass|ID])
	 * </pre>
	 */
	protected void sequence_RemoveCompleteReferenceMutator(ISerializationContext context, RemoveCompleteReferenceMutator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.REMOVE_COMPLETE_REFERENCE_MUTATOR__REF_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.REMOVE_COMPLETE_REFERENCE_MUTATOR__REF_TYPE));
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.OBJECT_EMITTER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.OBJECT_EMITTER__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRemoveCompleteReferenceMutatorAccess().getRefTypeEReferenceIDTerminalRuleCall_4_0_1(), semanticObject.eGet(MutatorenvironmentPackage.Literals.REMOVE_COMPLETE_REFERENCE_MUTATOR__REF_TYPE, false));
		feeder.accept(grammarAccess.getRemoveCompleteReferenceMutatorAccess().getTypeEClassIDTerminalRuleCall_6_0_1(), semanticObject.eGet(MutatorenvironmentPackage.Literals.OBJECT_EMITTER__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Mutator returns RemoveObjectMutator
	 *     RemoveObjectMutator returns RemoveObjectMutator
	 *
	 * Constraint:
	 *     (object=ObSelectionStrategy container=ObSelectionStrategy? (min=EInt? max=MaxCardinality)?)
	 * </pre>
	 */
	protected void sequence_RemoveObjectMutator(ISerializationContext context, RemoveObjectMutator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Mutator returns RemoveRandomReferenceMutator
	 *     RemoveReferenceMutator returns RemoveRandomReferenceMutator
	 *     RemoveRandomReferenceMutator returns RemoveRandomReferenceMutator
	 *
	 * Constraint:
	 *     (refType=[EReference|ID] type=[EClass|ID] (min=EInt? max=MaxCardinality)?)
	 * </pre>
	 */
	protected void sequence_RemoveRandomReferenceMutator(ISerializationContext context, RemoveRandomReferenceMutator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Mutator returns RemoveSpecificReferenceMutator
	 *     RemoveReferenceMutator returns RemoveSpecificReferenceMutator
	 *     RemoveSpecificReferenceMutator returns RemoveSpecificReferenceMutator
	 *
	 * Constraint:
	 *     (refType=[EReference|ID] container=ObSelectionStrategy (min=EInt? max=MaxCardinality)?)
	 * </pre>
	 */
	protected void sequence_RemoveSpecificReferenceMutator(ISerializationContext context, RemoveSpecificReferenceMutator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeEvaluationType returns ReplaceStringType
	 *     AttributeType returns ReplaceStringType
	 *     StringType returns ReplaceStringType
	 *     ReplaceStringType returns ReplaceStringType
	 *
	 * Constraint:
	 *     (operator=Operator oldstring=EString newstring=EString)
	 * </pre>
	 */
	protected void sequence_ReplaceStringType(ISerializationContext context, ReplaceStringType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.ATTRIBUTE_TYPE__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.ATTRIBUTE_TYPE__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.REPLACE_STRING_TYPE__OLDSTRING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.REPLACE_STRING_TYPE__OLDSTRING));
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.REPLACE_STRING_TYPE__NEWSTRING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.REPLACE_STRING_TYPE__NEWSTRING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReplaceStringTypeAccess().getOperatorOperatorEnumRuleCall_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getReplaceStringTypeAccess().getOldstringEStringParserRuleCall_4_0(), semanticObject.getOldstring());
		feeder.accept(grammarAccess.getReplaceStringTypeAccess().getNewstringEStringParserRuleCall_6_0(), semanticObject.getNewstring());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Resource returns Resource
	 *
	 * Constraint:
	 *     (name=ID path=Source metamodel=EString)
	 * </pre>
	 */
	protected void sequence_Resource(ISerializationContext context, Resource semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.RESOURCE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.RESOURCE__NAME));
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.RESOURCE__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.RESOURCE__PATH));
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.DEFINITION__METAMODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.DEFINITION__METAMODEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getResourceAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getResourceAccess().getPathSourceParserRuleCall_3_0(), semanticObject.getPath());
		feeder.accept(grammarAccess.getResourceAccess().getMetamodelEStringParserRuleCall_6_0(), semanticObject.getMetamodel());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Mutator returns RetypeObjectMutator
	 *     RetypeObjectMutator returns RetypeObjectMutator
	 *
	 * Constraint:
	 *     (
	 *         name=ID? 
	 *         object=ObSelectionStrategy 
	 *         container=ObSelectionStrategy? 
	 *         (type=[EClass|ID] | (types+=[EClass|ID] types+=[EClass|ID]*)) 
	 *         (attributes+=AttributeSet | references+=ReferenceSet)? 
	 *         attributes+=AttributeSet? 
	 *         (references+=ReferenceSet? attributes+=AttributeSet?)* 
	 *         (min=EInt? max=MaxCardinality)?
	 *     )
	 * </pre>
	 */
	protected void sequence_RetypeObjectMutator(ISerializationContext context, RetypeObjectMutator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RoundedBracketClauseCS returns RoundedBracketClauseCS
	 *
	 * Constraint:
	 *     (args+=ExpCS args+=ExpCS*)?
	 * </pre>
	 */
	protected void sequence_RoundedBracketClauseCS(ISerializationContext context, RoundedBracketClauseCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Mutator returns SelectObjectMutator
	 *     SelectObjectMutator returns SelectObjectMutator
	 *
	 * Constraint:
	 *     (name=ID object=ObSelectionStrategy container=ObSelectionStrategy?)
	 * </pre>
	 */
	protected void sequence_SelectObjectMutator(ISerializationContext context, SelectObjectMutator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Mutator returns SelectSampleMutator
	 *     SelectSampleMutator returns SelectSampleMutator
	 *
	 * Constraint:
	 *     (name=ID object=ObSelectionStrategy (clause=SampleClause features+=[EStructuralFeature|ID]? features+=[EStructuralFeature|ID]*)?)
	 * </pre>
	 */
	protected void sequence_SelectSampleMutator(ISerializationContext context, SelectSampleMutator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Source returns Source
	 *
	 * Constraint:
	 *     path=EString
	 * </pre>
	 */
	protected void sequence_Source(ISerializationContext context, Source semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.SOURCE__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.SOURCE__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSourceAccess().getPathEStringParserRuleCall_1_0(), semanticObject.getPath());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeEvaluationType returns SpecificBooleanType
	 *     AttributeType returns SpecificBooleanType
	 *     BooleanType returns SpecificBooleanType
	 *     SpecificBooleanType returns SpecificBooleanType
	 *
	 * Constraint:
	 *     (operator=Operator value=EBoolean)
	 * </pre>
	 */
	protected void sequence_SpecificBooleanType(ISerializationContext context, SpecificBooleanType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.ATTRIBUTE_TYPE__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.ATTRIBUTE_TYPE__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.SPECIFIC_BOOLEAN_TYPE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.SPECIFIC_BOOLEAN_TYPE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSpecificBooleanTypeAccess().getOperatorOperatorEnumRuleCall_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getSpecificBooleanTypeAccess().getValueEBooleanParserRuleCall_2_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ObSelectionStrategy returns SpecificClosureSelection
	 *     SpecificSelection returns SpecificClosureSelection
	 *     SpecificClosureSelection returns SpecificClosureSelection
	 *
	 * Constraint:
	 *     (objSel=[ObjectEmitter|ID] (refType=[EReference|ID] (refRefType=[EReference|ID] refRefRefType=[EReference|ID]?)?)? expression=Expression?)
	 * </pre>
	 */
	protected void sequence_SpecificClosureSelection(ISerializationContext context, SpecificClosureSelection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeEvaluationType returns SpecificDoubleType
	 *     AttributeType returns SpecificDoubleType
	 *     NumberType returns SpecificDoubleType
	 *     DoubleType returns SpecificDoubleType
	 *     SpecificDoubleType returns SpecificDoubleType
	 *
	 * Constraint:
	 *     (operator=Operator value=EDouble)
	 * </pre>
	 */
	protected void sequence_SpecificDoubleType(ISerializationContext context, SpecificDoubleType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.ATTRIBUTE_TYPE__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.ATTRIBUTE_TYPE__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.SPECIFIC_DOUBLE_TYPE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.SPECIFIC_DOUBLE_TYPE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSpecificDoubleTypeAccess().getOperatorOperatorEnumRuleCall_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getSpecificDoubleTypeAccess().getValueEDoubleParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeEvaluationType returns SpecificIntegerType
	 *     AttributeType returns SpecificIntegerType
	 *     NumberType returns SpecificIntegerType
	 *     IntegerType returns SpecificIntegerType
	 *     SpecificIntegerType returns SpecificIntegerType
	 *
	 * Constraint:
	 *     (operator=Operator value=EInt)
	 * </pre>
	 */
	protected void sequence_SpecificIntegerType(ISerializationContext context, SpecificIntegerType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.ATTRIBUTE_TYPE__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.ATTRIBUTE_TYPE__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.SPECIFIC_INTEGER_TYPE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.SPECIFIC_INTEGER_TYPE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSpecificIntegerTypeAccess().getOperatorOperatorEnumRuleCall_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getSpecificIntegerTypeAccess().getValueEIntParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ObSelectionStrategy returns SpecificObjectSelection
	 *     SpecificSelection returns SpecificObjectSelection
	 *     SpecificObjectSelection returns SpecificObjectSelection
	 *
	 * Constraint:
	 *     (objSel=[ObjectEmitter|ID] (refType=[EReference|ID] (refRefType=[EReference|ID] refRefRefType=[EReference|ID]?)?)? expression=Expression?)
	 * </pre>
	 */
	protected void sequence_SpecificObjectSelection(ISerializationContext context, SpecificObjectSelection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeEvaluationType returns SpecificStringType
	 *     AttributeType returns SpecificStringType
	 *     StringType returns SpecificStringType
	 *     SpecificStringType returns SpecificStringType
	 *
	 * Constraint:
	 *     (operator=Operator value=STRING)
	 * </pre>
	 */
	protected void sequence_SpecificStringType(ISerializationContext context, SpecificStringType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.ATTRIBUTE_TYPE__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.ATTRIBUTE_TYPE__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.SPECIFIC_STRING_TYPE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.SPECIFIC_STRING_TYPE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSpecificStringTypeAccess().getOperatorOperatorEnumRuleCall_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getSpecificStringTypeAccess().getValueSTRINGTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExpCS returns StringLiteralExpCS
	 *     LogicExpCS returns StringLiteralExpCS
	 *     LogicExpCS.LogicExpCS_1_0 returns StringLiteralExpCS
	 *     CallExpCS returns StringLiteralExpCS
	 *     CallExpCS.CallExpCS_1_0 returns StringLiteralExpCS
	 *     PrimaryExpCS returns StringLiteralExpCS
	 *     LiteralExpCS returns StringLiteralExpCS
	 *     StringLiteralExpCS returns StringLiteralExpCS
	 *
	 * Constraint:
	 *     stringSymbol=STRING
	 * </pre>
	 */
	protected void sequence_StringLiteralExpCS(ISerializationContext context, StringLiteralExpCS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniOCLPackage.Literals.STRING_LITERAL_EXP_CS__STRING_SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniOCLPackage.Literals.STRING_LITERAL_EXP_CS__STRING_SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralExpCSAccess().getStringSymbolSTRINGTerminalRuleCall_0(), semanticObject.getStringSymbol());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ObSelectionStrategy returns TypedSelection
	 *     TypedSelection returns TypedSelection
	 *
	 * Constraint:
	 *     ((type=[EClass|ID] | (types+=[EClass|ID] types+=[EClass|ID]*)) expression=Expression?)
	 * </pre>
	 */
	protected void sequence_TypedSelection(ISerializationContext context, TypedSelection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeEvaluationType returns UpperStringType
	 *     AttributeType returns UpperStringType
	 *     StringType returns UpperStringType
	 *     UpperStringType returns UpperStringType
	 *
	 * Constraint:
	 *     operator=Operator
	 * </pre>
	 */
	protected void sequence_UpperStringType(ISerializationContext context, UpperStringType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MutatorenvironmentPackage.Literals.ATTRIBUTE_TYPE__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MutatorenvironmentPackage.Literals.ATTRIBUTE_TYPE__OPERATOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUpperStringTypeAccess().getOperatorOperatorEnumRuleCall_1_0(), semanticObject.getOperator());
		feeder.finish();
	}
	
	
}
