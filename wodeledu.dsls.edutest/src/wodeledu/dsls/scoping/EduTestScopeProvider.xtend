/*
 * generated by Xtext 2.30.0
 */
package wodeledu.dsls.scoping;

import org.eclipse.xtext.scoping.IScope
import edutest.MutatorTests
import org.eclipse.emf.ecore.EReference
import wodel.utils.manager.ModelManager
import wodel.utils.manager.ProjectUtils
import java.util.ArrayList
import org.eclipse.emf.ecore.EPackage
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.common.util.URI
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.emf.ecore.EObject
import mutatorenvironment.Block
import org.osgi.framework.Bundle
import org.eclipse.core.runtime.Platform
import java.net.URL
import org.eclipse.core.runtime.FileLocator
import java.util.List
import edutest.TestConfiguration
import org.eclipse.emf.ecore.EClass
import edutest.Program
import org.eclipse.emf.ecore.EClassifier
import org.eclipse.emf.ecore.util.EcoreUtil

/**
 * @author Pablo Gomez-Abajo
 * 
 * Scope provider for the eduTest language.
 *
 */
class EduTestScopeProvider extends AbstractEduTestScopeProvider {
	/**
	 * MutatorTests.block can refers to any block declared in the .mutator file.
	 */
	def IScope scope_MutatorTests_block(MutatorTests mts, EReference ref) {
		val xmiFileName = "file:/" + ModelManager.getWorkspaceAbsolutePath + '/' + ProjectUtils.project.name + '/' + ModelManager.getOutputFolder + '/' +  mts.eResource.URI.lastSegment.replaceAll("test", "model")
		val Bundle bundle = Platform.getBundle("wodel.models")
	   	val URL fileURL = bundle.getEntry("/models/MutatorEnvironment.ecore")
	   	val String ecore = FileLocator.resolve(fileURL).getFile()
		val List<EPackage> mutatorpackages = ModelManager.loadMetaModel(ecore)
		val Resource mutatormodel = ModelManager.loadModel(mutatorpackages, URI.createURI(xmiFileName).toFileString)
		val List<EObject> eobjects = ModelManager.getObjectsOfType("Block", mutatormodel)
		var List<Block> blocks = new ArrayList<Block>()
		for (EObject eobject : eobjects) {
			blocks.add(eobject as Block)
		}
       	Scopes.scopeFor(blocks)   
	}	
	
	def IScope scope_TestConfiguration_statement(TestConfiguration test, EReference ref) {
		val List<EClass> scope = new ArrayList<EClass>()
		scope.addAll(getRootEClasses(((test.eContainer as MutatorTests).eContainer as Program).metamodel))
       	Scopes.scopeFor(scope)
	}		

	def IScope scope_TestConfiguration_answers(TestConfiguration test, EReference ref) {
		val List<EClass> scope = new ArrayList<EClass>()
		scope.addAll(getRootEClasses(((test.eContainer as MutatorTests).eContainer as Program).metamodel))
       	Scopes.scopeFor(scope)
	}		

	/** 
	 * It returns the list of classes defined in a meta-model.
	 * @param String file containing the metamodel
	 * @return List<EClass>
	 */
	 def private List<EClass> getEClassesSubpackages (EPackage pck) {
        val List<EClass>   classes   = new ArrayList<EClass>()
        for (EClassifier cl : pck.EClassifiers) {
          if (cl instanceof EClass)
      	    classes.add(cl as EClass)
   	    }
        for (EPackage spck : pck.ESubpackages) {
      	  val List<EClass> classesSubpackage = getEClassesSubpackages(spck)
      	  for (EClass cl : classesSubpackage) {
      	    if (!classes.contains(cl)) {
      	  	     classes.add(cl)
      	  	}
      	  }
      	}
        return classes
	 }

	/** 
	 * It returns the list of classes defined in a meta-model.
	 * @param String file containing the metamodel
	 * @return List<EClass>
	 */
	 def private List<EClass> getEClasses (String metamodelFile) {
        val List<EPackage> metamodel = ModelManager.loadMetaModel(metamodelFile)
        val List<EClass>   classes   = new ArrayList<EClass>()
   	    for (EPackage pck : metamodel) {
       	  for (EClassifier cl : pck.EClassifiers)
           	if (cl instanceof EClass)
      			classes.add(cl as EClass)
      	  for (EPackage spck : pck.ESubpackages) {
      	  	val List<EClass> classesSubpackage = getEClassesSubpackages(spck)
      	  	for (EClass cl : classesSubpackage) {
      	  		if (!classes.contains(cl)) {
      	  			classes.add(cl)
      	  		}
      	  	}
      	  }
		}
        return classes
	 }
	 
	 /**
	 * Gets the root EClass
	 */
	def EClass getRootEClass(List<EPackage> packages) {
		val List<EClass> eclasses = ModelManager.getEClasses(packages)
		for (EClass eclass : eclasses) {
			if (eclass.isAbstract() == false) {
				val List<EClassifier> containerTypes = ModelManager.getContainerTypes(packages, EcoreUtil.getURI(eclass))
				if (containerTypes.size() == 0) {
					return eclass
				}
			}
		}
		return null
	}
	
	 /** 
	 * It returns the list of root eclasses defined in a meta-model.
	 * @param String file containing the metamodel
	 * @return List<EClass>
	 */
	def private List<EClass> getRootEClassesSubpackages(List<EPackage> subpackages) {
		val List<EClass> roots = new ArrayList<EClass>()
		for (EPackage pck : subpackages) {
			val List<EPackage> pcks = new ArrayList<EPackage>()
			pcks.add(pck)
			roots.add(getRootEClass(pcks))
			if (pck.getESubpackages() !== null && pck.getESubpackages().size() > 0) {
				roots.addAll(getRootEClassesSubpackages(pck.getESubpackages()))
			}
		}
		return roots
	}

	/**
	 * Gets the root EClass
	 */
	def List<EClass> getRootEClasses(String metamodelFile) {
		val List<EPackage> metamodel = ModelManager.loadMetaModel(metamodelFile)
		val List<EClass> roots = new ArrayList<EClass>()
		roots.add(getRootEClass(metamodel))
		val List<EPackage> pcks = new ArrayList<EPackage>()
		pcks.addAll(metamodel)
		for (EPackage pck : pcks) {
			if (pck.getESubpackages() !== null && pck.getESubpackages().size() > 0) {
				roots.addAll(getRootEClassesSubpackages(pck.getESubpackages()))
			}
		}
		return roots
	}
}

